<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>SALOME Kernel resources for developer: Trace and debug Utilities</TITLE>
 <LINK HREF="kernel_resources-2.html" REL=next>

 <LINK HREF="kernel_resources.html#toc1" REL=contents>
</HEAD>
<BODY>
<A HREF="kernel_resources-2.html">Next</A>
Previous
<A HREF="kernel_resources.html#toc1">Contents</A>
<HR>
<H2><A NAME="s1">1. Trace and debug Utilities</A></H2>

<P>During the development process, an execution log is useful to
identify problems. This log contains messages, variables values,
source files names and line numbers. It is recommended to verify
assertions on variables values and if necessary, to stop the execution
at debug time, in order to validate all parts of code.
<H2><A NAME="ss1.1">1.1 Two modes: debug and release</A>
</H2>

<P>The goal of debug mode is to check as many features as possible
during the early stages of the development process. The purpose of
the utilities provided in SALOME is to help the developer to add
detailed traces and check variables values, without writing a lot
of code.
<P>When the code is assumed to be valid, the release mode optimizes
execution, in terms of speed, memory, and display only user level
messages.
<P>But, some informations must always be displayed in both modes:
especially messages concerning environment or internal errors, with
version identification. When an end user is confronted to such a
message, he may refer to a configuration documentation or send the
message to the people in charge of SALOME installation, or to the
development team, following the kind of error.
<H2><A NAME="ss1.2">1.2 C++ Macros for trace and debug</A>
</H2>

<P>SALOME provides C++ macros for trace and debug. These macros
are in <CODE>SALOME/src/utils/utilities.h</CODE> and this file must be included
in C++ source. Some macros are activated only in debug mode, others
are always activated. To activate the debug mode, <CODE>_DEBUG_</CODE> must be
defined, which is the case when SALOME Makefiles are generated from
configure, without options. When <CODE>_DEBUG_</CODE> is undefined (release mode),
the debug mode macros are defined empty (they do nothing). So, when
switching from debug to release, it is possible (and recommended)
to let the macro calls unchanged in the source.
<P>All the macros writing on the standard output start by flushing
the standard error. At the end of the display those macros flush
the standard output.
<P>Two informations are systematically added in front of the information
displayed:
<P>
<UL>
<LI>the name of the source file in which the macros is set;</LI>
<LI>the line number of the source file at which the macro is set.</LI>
</UL>
<H3>Macros defined in debug and release modes</H3>

<H3>INFOS_COMPILATION</H3>

<P>The C++ macro <CODE>INFOS_COMPILATION</CODE> writes on the standard output
informations about the compiling process: 
<P>
<UL>
<LI>the name of the compiler : <CODE>g++, KCC, CC, pgCC</CODE>;</LI>
<LI>the date and the time of the compiling processing process.</LI>
</UL>
<P>This macro <CODE>INFOS_COMPILATION</CODE> does not have any argument. Moreover,
it is defined in both compiling mode : <CODE>_DEBUG_</CODE> and <CODE>_RELEASE_</CODE>.
<P>Example :
<P>
<PRE>
#include &quot;utilities.h&quot;
int main(int argc , char **argv) 
{ 
  INFOS_COMPILATION;
  ...
}
</PRE>
<H3>INFOS(str)</H3>

<P>In both compiling mode <CODE>_DEBUG_</CODE> and <CODE>_RELEASE_</CODE>, The C++ macro <CODE>INFOS</CODE>
writes on the standard output the string which has been passed in
argument by the user.
<P>Example : 
<P>
<PRE>
#include &quot;utilities.h&quot;
int main(int argc , char **argv)
{ 
  ... 
  INFOS(&quot;NORMAL END OF THE PROCESS&quot;); 
  return 0; 
}
</PRE>
<P>displays :
<P>
<PRE>
main.cxx [5] : NORMAL END OF THE PROCESS
</PRE>
<H3>Macros defined only in debug mode</H3>

<H3>MESSAGE(str)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode only, the C++ macro <CODE>MESSAGE</CODE> writes
on the standard output the string which has been passed in argument
by the user. In <CODE>_RELEASE_</CODE> compiling mode, this macro is blank.
<P>Example : 
<P>
<PRE>
#include &quot;utilities.h&quot; 
#include &lt;string&gt; 
using namespace std; 
int main(int argc , char **argv) 
{ 
  ... 
  const char *str = &quot;Salome&quot;;
  MESSAGE(str);
  ... const string st; 
  st = &quot;Aster&quot;; 
  MESSAGE(c_str(st+&quot; and CASTEM&quot;)); 
  return 0;
}
</PRE>
<P>displays :
<P>
<PRE>
- Trace main.cxx [8] : Salome
- Trace main.cxx [12] : Aster and CASTEM
</PRE>
<H3>BEGIN_OF(func_name)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode, The C++ macro <CODE>BEGIN_OF</CODE> appends the
string <CODE>&quot;Begin of &quot;</CODE> to the one passed in argument by the
user and displays the result on the standard output. In <CODE>_RELEASE_</CODE>
compiling mode, this macro is blank.
<P>Example : 
<P>
<PRE>
#include &quot;utilities.h&quot; 
int main(int argc , char **argv) 
{ 
  BEGIN_OF(argv[0]);
  return 0;
}
</PRE>
<P>displays : 
<P>
<PRE>
- Trace main.cxx [3] : Begin of a.out
</PRE>
<H3>END_OF(func_name)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode, The C++ macro <CODE>END_OF</CODE> appends the string
<CODE>&quot;Normal end of &quot;</CODE> to the one passed in argument by the user
and displays the result on the standard output. In <CODE>_RELEASE_</CODE> compiling
mode, this macro is blank.
<P>Example : 
<P>
<PRE>
#include &quot;utilities.h&quot; 
int main(int argc , char **argv) 
{ 
  END_OF(argv[0]);
  return 0; 
}
</PRE>
<P>displays : 
<P>
<PRE>
- Trace main.cxx [4] : Normal end of a.out
</PRE>
<H3>SCRUTE(var)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode, The C++ macro <CODE>SCRUTE</CODE> displays its
argument which is an application variable followed by the value of
the variable. In <CODE>_RELEASE_</CODE> compiling mode, this macro is blank.
<P>Example : 
<P>
<PRE>
#include &quot;utilities.h&quot;
int main(int argc , char **argv) 
{ 
  const int i=999;
  if( i &gt; 0 ) SCRUTE(i) ; i=i+1;
  return 0;
}
</PRE>
<P>displays :
<P>
<PRE>
- Trace main.cxx [5] : i=999
</PRE>
<H3>ASSERT(condition)</H3>

<P>In <CODE>_DEBUG_</CODE> compiling mode only, The C++ macro <CODE>ASSERT</CODE> checks the
expression passed in argument to be not NULL. If it is NULL the process
is stopped and the condition is written on the standard output. In
<CODE>_RELEASE_</CODE> compiling mode, this macro is blank. N.B. : if <CODE>ASSERT</CODE> is
already defined, this macro is ignored.
<P>Example :
<P>
<PRE>
#include &quot;utilities.h&quot; 
... 
const char *ptrS = fonc();
ASSERT(ptrS!=NULL); 
cout &lt;&lt; strlen(ptrS); 
float table[10];
int k;
... 
ASSERT(k&lt;10);
cout &lt;&lt; table[k];
</PRE>
<HR>
<A HREF="kernel_resources-2.html">Next</A>
Previous
<A HREF="kernel_resources.html#toc1">Contents</A>
</BODY>
</HTML>
